import osimport timefrom PyQt5.QtCore import QObject, pyqtSignal, pyqtSlot, QRunnable, QThreadPoolfrom Soundexy.Functionality.useful_utils import get_app_data_folder, make_folder_if_it_does_not_existfrom Soundexy.Indexing import Indexingclass IndexerSigs(QObject):    started_adding_items = pyqtSignal()    added_item = pyqtSignal(str)    saving = pyqtSignal(int)    finished_adding_items = pyqtSignal()    deleted_item = pyqtSignal(str)    error = pyqtSignal(str)class Indexer(QRunnable):    def __init__(self):        super(Indexer, self).__init__()        self.index_file_name = 'local'        self.signals = IndexerSigs()        self.paths = []        self.emitted_start_adding_items = False    @staticmethod    def emit_signal_if_condition_false(signal: pyqtSignal, condition: bool):        if not condition:            signal.emit()            return True        else:            return False    def emit_started_adding_items(self, index):        if self.emit_signal_if_condition_false(self.signals.started_adding_items, self.emitted_start_adding_items):            index.signals.added_item.connect(lambda x: self.signals.added_item.emit(x))            index.signals.saving.connect(lambda x: self.signals.saving.emit(x))            self.emitted_start_adding_items = True    def run(self):        self.reset()        index = IndexFile(self.index_file_name, schema=Indexing.ResultSchema)        self.emit_started_adding_items(index)        index.add_paths_to_index(self.paths)        index.save()        if self.emitted_start_adding_items:            self.signals.finished_adding_items.emit()    def reset(self):        self.emitted_start_adding_items = Falseclass IndexFileSigs(QObject):    error = pyqtSignal(str)    added_item = pyqtSignal(str)    deleted_item = pyqtSignal(str)    saving = pyqtSignal(int)time_to_make_numbs = []class IndexFile:    def __init__(self, file_name, app_data_folder=get_app_data_folder("index"), schema=Indexing.ResultSchema):        self.index_file_name = file_name        self.signals = IndexFileSigs()        self.schema = schema()        self.emitted_start_adding_items = False        self.excepted_file_types = ['.mp3', '.wav', '.flac', '.ogg']        self.index = None        self.app_data_folder = app_data_folder        self.writer = None        self.load()        self.counter = 0    def determine_if_file_should_be_added_to_index(self, file_path):        extension = os.path.splitext(file_path)[1]        if extension.lower() in self.excepted_file_types:            return True    def add_paths_to_index(self, paths):        for path in paths:            print(path)            if os.path.isdir(path):                self.add_dir_to_index(path)            elif os.path.isfile(path):                self.add_single_to_index(path)    def add_dir_to_index(self, path):        for root, dirs, files in os.walk(path):            for file in files:                start_time = time.time()                file_path = os.path.join(root, file.title())                self.add_single_to_index(file_path)                time_to_make_numbs.append(time.time() - start_time)    def add_single_to_index(self, path):        if self.determine_if_file_should_be_added_to_index(path):            self.append_result_to_index(Indexing.make_document(path))            self.signals.added_item.emit(path)            self.counter += 1            if self.counter >= 100000:                self.save()    def add_result_to_index(self, result):        self.append_result_to_index(result.meta_file)    def make_result(self, index, file_path):        first_letter = self.index_file_name[0].upper()        # i = first_letter + '%08d' % len(index)        # if local_result.populate(file_path, i):        #     return local_result    def append_result_to_index(self, result):        try:            Indexing.write_to_index(self.writer, **result)        except (AttributeError, Indexing.w_writing.IndexingError):            self.writer = self.index.writer()            self.append_result_to_index(result)        except Indexing.SchemaModifiedWhileWriting:            self.save()            self.append_result_to_index(result)    def changed_meta_data(self, result):        self.append_result_to_index(result)        self.save()    def delete_from_index(self, result):        # try:            self.index.delete_by_term("id", result.id)        # except FileNotFoundError as e:        #     self.signals.error.emit(e)        # else:        #     self.save()    def save(self):        self.signals.saving.emit(self.counter)        self.writer.commit()        self.counter = 0    def load(self):        path = make_folder_if_it_does_not_exist(self.app_data_folder, self.index_file_name)        try:            self.index = Indexing.open_index(path)        except Indexing.w_index.EmptyIndexError:            self.index = Indexing.create_index(path, self.schema)            print('Made New Index File Named: ' + self.index_file_name)class LocalSearchSigs(QObject):    started = pyqtSignal()    batch_found = pyqtSignal(list)    updated_results = pyqtSignal(Indexing.ResultsPage)    finished = pyqtSignal()class IndexSearch(QRunnable):    def __init__(self, search_text, index_app_data=get_app_data_folder("index"), index_name="local", batch_amount=50,                 sort_by=""):        super(IndexSearch, self).__init__()        self.search_text = search_text        self.signals = LocalSearchSigs()        self.index_path = index_app_data        self.index_name = index_name        self.batch_amount = batch_amount        self.sort_by = sort_by        self.canceled = False    def emit_batch(self, results):        if not self.canceled:            time.sleep(.2)            self.signals.batch_found.emit(results)    def update_results(self, results):        if not self.canceled:            self.signals.updated_results.emit(results)    @pyqtSlot()    def run(self):        try:            index = IndexFile(self.index_name, app_data_folder=self.index_path, schema=Indexing.ResultSchema).index        except FileNotFoundError:            print("File Not Found")        else:            self.signals.started.emit()            query = Indexing.construct_query(index, self.search_text)            results = list(Indexing.search_index(index, query, sort_by=self.sort_by))            c = 0            page = []            for result in results:                if self.canceled:                    break                if c % 100 == 0:                    self.emit_batch(page)                    page = []                page.append(result)                c += 1            if len(page) > 0:                self.emit_batch(page)        self.signals.finished.emit()    def search(self):        try:            index = IndexFile(self.index_name).index        except FileNotFoundError:            print("File Not Found")        else:            query = Indexing.construct_query(index, self.search_text)            return list(Indexing.search_index(index, query, sort_by=self.sort_by))    def cancel(self):        self.canceled = True